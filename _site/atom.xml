<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.7">Jekyll</generator><link href="http://0.0.0.0:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2020-06-01T14:09:54-05:00</updated><id>http://0.0.0.0:4000/atom.xml</id><entry><title type="html">MySQL y los emojis</title><link href="http://0.0.0.0:4000/mysql-emojis.html" rel="alternate" type="text/html" title="MySQL y los emojis" /><published>2020-05-18T00:00:00-05:00</published><updated>2020-05-18T00:00:00-05:00</updated><id>http://0.0.0.0:4000/mysql-emojis</id><content type="html" xml:base="http://0.0.0.0:4000/mysql-emojis.html">&lt;p&gt;Esta es la t√≠pica tonter√≠a in√∫til que da problemas, veamos como se implementa y donde puede haber problemas, al grano, vemos todo lo que hace falta para que funcione, y los ejemplos que trataremos est√°n hechos para saber investigar el problema y poder resolverlo:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Debes utilizar el encoding &lt;code class=&quot;highlighter-rouge&quot;&gt;utf8mb4&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;El encoding debe estar configurado en varios sitios; en las tablas a usar, en la conexi√≥n de la aplicaci√≥n y en las variables de entorno. En este punto es donde suele haber problemas.&lt;/li&gt;
  &lt;li&gt;Debes asegurarte de que los datos se guardan y se recuperan bien.&lt;/li&gt;
  &lt;li&gt;Realiza pruebas en un entorno seguro y controlado.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Si ya estas utilizando el encoding &lt;code class=&quot;highlighter-rouge&quot;&gt;utf8&lt;/code&gt; no es problema que implementes &lt;code class=&quot;highlighter-rouge&quot;&gt;utf8mb4&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Vamos a crear primero una tabla como debe ser, luego modificar una tabla existente y luego agregamos varios registros de ejemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;DROP TABLE IF EXISTS foo;
CREATE TABLE IF NOT EXISTS `foo` (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT,
  `text` varchar(2000) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

INSERT INTO foo (`text`) VALUES (&quot;test case&quot;);
INSERT INTO foo (`text`) VALUES (&quot;üöå&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Podemos modificar una tabla existente para que use &lt;code class=&quot;highlighter-rouge&quot;&gt;utf8mb4&lt;/code&gt;, en el ejemplo pongo como crear la tabla y luego como modificarla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;DROP TABLE IF EXISTS foo;
CREATE TABLE IF NOT EXISTS `foo` (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT,
  `text` varchar(2000) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

ALTER TABLE foo CONVERT TO CHARACTER SET utf8mb4;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ADVERTENCIA:&lt;/strong&gt; Cuidado con el tamano de la tabla a la hora de modificarla, y el encoding diferente al &lt;code class=&quot;highlighter-rouge&quot;&gt;utf8&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ahora insertamos varios registros y vemos que pasa:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;INSERT INTO foo (`text`) VALUES (&quot;test case&quot;);
INSERT INTO foo (`text`) VALUES (&quot;üöå&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Posiblemente se te genere la siguiente salida, donde el primer registro se agrego perfectamente pero en el segundo registro tienes &lt;strong&gt;2 warnings&lt;/strong&gt;, hay que prestar mucho a esa informaci√≥n que suele ser ignorada.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; INSERT INTO foo (`text`) VALUES (&quot;test case&quot;);
Query OK, 1 row affected (0.01 sec)

mysql&amp;gt; INSERT INTO foo (`text`) VALUES (&quot;üöå&quot;);
Query OK, 1 row affected, 2 warnings (0.01 sec)

mysql&amp;gt; SHOW WARNINGS;
+---------+------+-----------------------------------------------------------------------+
| Level   | Code | Message                                                               |
+---------+------+-----------------------------------------------------------------------+
| Warning | 1300 | Invalid utf8 character string: 'F09F9A'                               |
| Warning | 1366 | Incorrect string value: '\xF0\x9F\x9A\x8C' for column 'text' at row 1 |
+---------+------+-----------------------------------------------------------------------+
2 rows in set (0.00 sec)

mysql&amp;gt; SELECT * FROM foo;
+----+-----------+
| id | text      |
+----+-----------+
|  1 | test case |
|  2 | ????      |
+----+-----------+
2 rows in set (0.00 sec)

mysql&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Como puedes ver, usando el comando &lt;code class=&quot;highlighter-rouge&quot;&gt;SHOW WARNINGS&lt;/code&gt; te lista los mensajes, aqu√≠ podemos observar no hay compatibilidad con el emoji y sobre escribe el valor de dicho emoji para hacerlo compatible al &lt;code class=&quot;highlighter-rouge&quot;&gt;CHARACTER_SET&lt;/code&gt; actual, tambi√©n puedes observar que hiciste &lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT&lt;/code&gt; del contenido de la tabla y no est√° el emoji sino una serie de s√≠mbolos,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;SELECT id, `text`, HEX(`text`) FROM foo WHERE id = 2;
SELECT HEX(&quot;üöå&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Es cierto que se creo antes la tabla con el soporte a &lt;code class=&quot;highlighter-rouge&quot;&gt;utf8mb4&lt;/code&gt; y a√∫n as√≠ esta dando problemas, debemos revisar las variables del servidor relacionadas a este tipo de configuraci√≥n, posiblemente nos falta algo, hagamos la siguiente consulta para averiguarlo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;SELECT @@collation_connection,
       @@collation_database,
       @@collation_server,
       @@character_set_client,
       @@character_set_connection,
       @@character_set_database,
       @@character_set_filesystem,
       @@character_set_results,
       @@character_set_server,
       @@character_set_system,
       @@init_connect\G
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Por ejemplo no usamos la sentencia &lt;code class=&quot;highlighter-rouge&quot;&gt;SHOW VARIABLES LIKE 'character%';&lt;/code&gt; y su variante porque debes ejecutarla por cada tipo de variables [collation&lt;/td&gt;
      &lt;td&gt;character] o una variable en espec√≠fico, es cosa tuya. De la query anterior posiblemente obtengamos el siguiente resultado:&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*************************** 1. row ***************************
    @@collation_connection: utf8_general_ci
      @@collation_database: latin1_swedish_ci
        @@collation_server: latin1_swedish_ci
    @@character_set_client: utf8
@@character_set_connection: utf8
  @@character_set_database: latin1
@@character_set_filesystem: binary
   @@character_set_results: utf8
    @@character_set_server: latin1
    @@character_set_system: utf8
            @@init_connect:
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ya podemos ver que tenemos un desorden en las variables, toda una ensalada de opciones, deber√≠amos unificar el mayor n√∫mero de opciones. Como hemos dicho, necesitamos tener definida la opci√≥n &lt;code class=&quot;highlighter-rouge&quot;&gt;utf8mb4&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Tampoco est√° dem√°s verificar el collation de la tabla:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;SELECT table_collation FROM information_schema.tables WHERE table_schema = 'demo' AND table_name = 'foo';
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Como la creamos nosotros desde el principio, y no te olvidaste de hacer el ALTER, seguramente todo est√° bien, ahora cambiamos la configuraci√≥n en la sesi√≥n actual de la conexi√≥n y actualizamos el registro problem√°tico y verificamos que todo est√° bien:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-SQL&quot;&gt;SET character_set_client = 'utf8mb4'; SET character_set_connection = 'utf8mb4'; SET character_set_results = 'utf8mb4';
UPDATE demo.foo SET `text` = &quot;üöå&quot; WHERE id = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Es muy importante que en la conexi√≥n de nuestro c√≥digo que usa la base de datos y dicha tabla se le especifique el &lt;code class=&quot;highlighter-rouge&quot;&gt;CHARACTER_SET&lt;/code&gt; para evitar alg√∫n problema, este es un ejemplo en python, consulta tu lenguaje y/o framework.&lt;/p&gt;

&lt;script src=&quot;https://emgithub.com/embed.js?target=https%3A%2F%2Fgithub.com%2Fswapbyt3s%2FMyScripts%2Fblob%2Fmaster%2Fexamples%2Fpython%2Fmysql_emoji.py&amp;amp;style=github&amp;amp;showBorder=on&amp;amp;showLineNumbers=on&amp;amp;showFileMeta=on&quot;&gt;&lt;/script&gt;

&lt;p&gt;Fin.&lt;/p&gt;</content><author><name></name></author><category term="mysql" /><category term="collation" /><summary type="html">Esta es la t√≠pica tonter√≠a in√∫til que da problemas, veamos como se implementa y donde puede haber problemas, al grano, vemos todo lo que hace falta para que funcione, y los ejemplos que trataremos est√°n hechos para saber investigar el problema y poder resolverlo:</summary></entry><entry><title type="html">MySQL y los Timeouts</title><link href="http://0.0.0.0:4000/mysql-timeouts.html" rel="alternate" type="text/html" title="MySQL y los Timeouts" /><published>2020-05-16T00:00:00-05:00</published><updated>2020-05-16T00:00:00-05:00</updated><id>http://0.0.0.0:4000/mysql-timeouts</id><content type="html" xml:base="http://0.0.0.0:4000/mysql-timeouts.html">Suele pasar mucho con los de **business intelligence, data science y sus variantes**, puede deberse a varias razones, vamos al grano:

- Si te conectas desde tu casa u oficina al cloud para traer informaci√≥n, la realidad es que la intermitencia no la puedes controlar, puede ser por el ISP, o por la VPN o quien sabe que.
- Vol√∫menes de datos muy grandes. Haz que la query retorne vol√∫menes m√°s peque√±os, en vez de todo el mes, que sea por d√≠a.
- Tiempos de respuesta muy elevados, te falta un indice √≥ por la misma raz√≥n debes hacer lo anterior, traerte trozos peque√±os y razonables de datos, o alg√∫n bloqueo.
- Estas tratando con una ddbb transaccional por lo que los tiempos est√°n ajustados para ello y m√°s si es una aplicaci√≥n web que no debe tardar m√°s de 30s en responder por ejemplo porque sino el hilo de ejecuci√≥n del web server muere.

Se podr√≠a configurar el cliente o tu script o programa para que cambie esos tiempos a la hora de establecer la conexi√≥n y recibir los datos, pero antes debes saber que hay definido y luego ver que ajustas. Haz la siguiente query:

```sql
SELECT @@net_write_timeout, @@wait_timeout;
```
Cada vez que el cliente se conecta hereda una serie de configuraciones globales, pero tambi√©n puedes ajustar algunas de ellas en tu sesi√≥n, como lo vamos hacer ahora. Cada una de esas variables significa algo:

- **net_write_timeout:** Indica la cantidad de segundos en que el servidor escribe al cliente y debe esperar para abortar la conexi√≥n.
- **wait_timeout:** Indica la cantidad de segundos sin actividad que debe esperar para abortar la conexi√≥n.
Como ajustas wait_timeout:

```sql
SET SESSION wait_timeout = 300;
SELECT * FROM book WHERE year BETWEEN 2000 AND 2001;
```

Esto es bastante de probar y ajustar hasta conseguir los valores adecuados, recuerda que la cache y el buffer pool tambi√©n pueden jugartela con los tiempos de respuesta.

Las variables las puedes cambiar en su conexi√≥n / session de MySQL sin perjudicar el resto del comportamiento del cluster.

Adicionalmente, recomiendo hacer lecturas de datos sin generar bloqueos que pueda comprometer la replicaci√≥n o una transacci√≥n entre otras cosas, para ello debes definir el nivel de aislamiento transaccional:

```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED ;
SELECT * FROM book WHERE year BETWEEN 2000 AND 2001;
```

Fin.</content><author><name></name></author><category term="mysql" /><category term="timeout" /><summary type="html">Suele pasar mucho con los de business intelligence, data science y sus variantes, puede deberse a varias razones, vamos al grano:</summary></entry><entry><title type="html">El teorema CAP</title><link href="http://0.0.0.0:4000/teorema-cap.html" rel="alternate" type="text/html" title="El teorema CAP" /><published>2016-06-12T00:00:00-05:00</published><updated>2016-06-12T00:00:00-05:00</updated><id>http://0.0.0.0:4000/teorema-cap</id><content type="html" xml:base="http://0.0.0.0:4000/teorema-cap.html">√âste post me parece muy importante para poder entender como funcionan y hacer grandes sistemas pensados para escalar, sea por tr√°fico, por multi-sitio, multi-pa√≠s, y m√°s‚Ä¶ todos estos sistemas distribuidos presentan la misma particularidad, y en el a√±o 2000 un se√±or llamado [Eric Brewer](https://en.wikipedia.org/wiki/CAP_theorem), pudo definir tres importantes propiedades y desarrollo un teorema. El se dio cuenta que mientras m√°s aplicaciones basadas en la WEB existan, menos debemos preocuparnos por la consistencia de los datos, si queremos alta disponibilidad de nuestras aplicaciones entonces no podemos garantizar la consistencia de los datos.

El teorema CAP, tambi√©n llamado formalmente Teorema de Brewer, dice que un **sistema de datos distribuido pude asegurar dos de estas tres propiedades: Consistencia, Disponibilidad y Tolerancia al particionado.** Bien, que significa cada una:

- La consistencia (Consistency), Todos los nodos deben ver los mismos datos al mismo tiempo, esto quiere decir que; cualquier cambios en los datos se debe aplicar en todos los nodos, y cuando se recupere el dato tiene que ser el mismo en todos los nodos. Esto se le llama consistencia at√≥mica, y se consigue replicando la informaci√≥n en todos los nodos.
- La disponibilidad (Availability), Cada petici√≥n en un nodo debe recibir y garantizar una confirmaci√≥n si ha sido resuelta satisfactoriamente. En pocas palabras, se debe leer y escribir en todos los nodos.
- La tolerancia al particionado (Partition Tolerance), El sistema debe funcionar a pesar de que haya sido dividido por un fallo de comunicaci√≥n, garantizando la disponibilidad a pesar que un nodo se separe del grupo sin importar la causa.

![El teorema CAP]({{ &quot;/assets/CAPTheorem.png&quot; | absolute_url }})

El teorema solo nos puede garantizar las siguientes combinaciones:

- CP (Consistency &amp; Partition): El sistema aplicara los cambios de forma forma consistente y aunque se pierda la comunicaci√≥n entre nodos ocacionando el particionado, no se asegura que haya disponibilidad.
- AP (Availability &amp; Partition): El sistema siempre estar√° disponible a las peticiones aunque se pierda la comunicaci√≥n entre los nodos ocacionando el particionado, y en consecuencia por la perdida de comunicaci√≥n existir√° inconsistencia porque no todos los nodos ser√°n iguales.
- CA (Consistency &amp; Availability): El sistema siempre estar√° disponible respondiendo las peticiones y los datos procesados ser√°n consistentes. En este caso no se puede permitir el particionado.

La correcta decisi√≥n de que combinaci√≥n necesitamos depende de nuestras necesidades de negocio. Nunca olvide que lo m√°s importante en una base de datos relacional es la Consistencia. Conociendo el teorema CAP, nos puede ayudar a√∫n m√°s para saber que Sistemas de Base de Datos debemos escoger, si un SQL o un NoSQL. Si queremos profundizar m√°s en el tema, recomiendo [este post](http://www.julianbrowne.com/article/brewers-cap-theorem).</content><author><name></name></author><category term="database" /><summary type="html">√âste post me parece muy importante para poder entender como funcionan y hacer grandes sistemas pensados para escalar, sea por tr√°fico, por multi-sitio, multi-pa√≠s, y m√°s‚Ä¶ todos estos sistemas distribuidos presentan la misma particularidad, y en el a√±o 2000 un se√±or llamado Eric Brewer, pudo definir tres importantes propiedades y desarrollo un teorema. El se dio cuenta que mientras m√°s aplicaciones basadas en la WEB existan, menos debemos preocuparnos por la consistencia de los datos, si queremos alta disponibilidad de nuestras aplicaciones entonces no podemos garantizar la consistencia de los datos.</summary></entry><entry><title type="html">Actualizar datos de una tabla sin bloquearla desde un archivo</title><link href="http://0.0.0.0:4000/actualizar-bloquearla.html" rel="alternate" type="text/html" title="Actualizar datos de una tabla sin bloquearla desde un archivo" /><published>2016-04-11T00:00:00-05:00</published><updated>2016-04-11T00:00:00-05:00</updated><id>http://0.0.0.0:4000/actualizar-bloquearla</id><content type="html" xml:base="http://0.0.0.0:4000/actualizar-bloquearla.html">Hay muchas formas de hacerlo, para variar quise buscar una alternativa r√°pida y eficaz para evitar escribir un nuevo script, y se me ocurri√≥ usar los comandos de linux, la verdad que resulto muy bien, aqu√≠ les dejo un ejemplo:

```bash
cat tokens.csv \
| \
awk -F ',' '{ print &quot;UPDATE users SET token = \&quot;&quot; $2 &quot;\&quot; WHERE token IS NULL AND email = \&quot;&quot; $1 &quot;\&quot;;&quot;; system(&quot;sleep 0.1&quot;);}' \
| \
mysql --login-path=foo \
      --safe-updates \
      --batch \
      --silent \
      --database=foo`
```

Explico un poco, b√°sicamente se lee el archivo con cat, luego se crea la sentencia UPDATE usando el awk, por cada update hacemos una pausa de 100 milisegundo para no saturar, y se lo mandamos al cliente de MySQL.

De vez en cuando nos toca hacer un gran UPDATE sobre una tabla grande que nos puede llevar 10 min. para completar su ejecuci√≥n, el problema es que si lo hacemos directamente bloqueamos la tabla hasta que termine, eso puede ocasionar varios problemas muy graves a nivel de aplicaci√≥n, hoy presento una alternativa usando Procedimientos Almacenados.

B√°sicamente consiste en tener una sentencia que hace UPDATE a cada 1000 rows, se ejecuta dicha query N veces hasta llegar a 0 rows actualizados, en cada interacci√≥n hacemos una peque√±a pausa de 2 segundos para dejar que pasen las transacciones que est√°n esperando usar dicho recurso.

```SQL
DROP PROCEDURE IF EXISTS sp_users_update;

DELIMITER |
CREATE PROCEDURE sp_users_update()
  BEGIN
    SET @row_count = 0;

    REPEAT
      -- Query to update:
      UPDATE LOW_PRIORITY users SET username = CONCAT('DELETED_', username)
      WHERE deleted_at IS NOT NULL
      AND username NOT LIKE 'DELETED_%'
      LIMIT 1000;

      -- Save row counts for update:
      SET @row_count = (SELECT ROW_COUNT());

      -- Sleep for not blocking table:
      SELECT SLEEP(2);
    UNTIL @row_count = 0 END REPEAT;
  END;
|
DELIMITER ;

CALL sp_users_update();

DROP PROCEDURE IF EXISTS sp_users_update;
```

La verdad que es una alternativa r√°pida a comparaci√≥n de un script, es cierto que el proceso de buscar con LIKE es algo costoso para la CPU si son muchos rows, de echo pude observar un pico durante la actualizaci√≥n, nada grave por ser una situaci√≥n controlada y probada en otros entornos.</content><author><name></name></author><category term="mysql" /><category term="update" /><category term="lock" /><summary type="html">Hay muchas formas de hacerlo, para variar quise buscar una alternativa r√°pida y eficaz para evitar escribir un nuevo script, y se me ocurri√≥ usar los comandos de linux, la verdad que resulto muy bien, aqu√≠ les dejo un ejemplo:</summary></entry><entry><title type="html">Monitorizar y resolver problemas de replicaci√≥n en MySQL</title><link href="http://0.0.0.0:4000/monitorizar-resolver-problemas-replicacion-mysql.html" rel="alternate" type="text/html" title="Monitorizar y resolver problemas de replicaci√≥n en MySQL" /><published>2016-03-05T00:00:00-06:00</published><updated>2016-03-05T00:00:00-06:00</updated><id>http://0.0.0.0:4000/monitorizar-resolver-problemas-replicacion-mysql</id><content type="html" xml:base="http://0.0.0.0:4000/monitorizar-resolver-problemas-replicacion-mysql.html">La replicaci√≥n de datos con slaves es algo muy f√°cil de configurar y aporta muchos beneficios, pero aveces trae sus grandes problemas si no tenemos en cuenta algunos aspectos de configuraci√≥n, hardware y red entre otras cosas, vamos a comentar un buen grupo de ellos y ayudarte a saber donde puede estar el problema, se que es muy largo el POST, hay mucho que cubrir, pero tratare de dar la idea.

## Ventajas de usar Slaves

* Divide las escrituras en un master y lecturas en los slaves para distribuir las cargas de trabajo. Esto no lo hace MySQL de forma transparente, la aplicaci√≥n debe saber que sentencias van al master y al slave.
* Los Slaves que son los servidores de lectura, se pueden optimizar para hacer miner√≠a de datos o procesos de reportes.
* Se puede usar un slave para remplazar el master en caso de alg√∫n desastre como una medida de prevenci√≥n.
* Como respaldo usando el retraso en la replicaci√≥n para recuperar datos, ver la variable [MASTER_DELAY][1].
* Incluso podemos configurar el MultiMaster de dos nodos, pero esto aveces no funciona bien por como esta programada la aplicaci√≥n.

Los problemas que surgen por la replicaci√≥n no son nuevos, podemos clasificarlos en dos grandes grupos; Cuando se interrumpe la replicaci√≥n por alguna inconsistencia, o un retraso de la replicaci√≥n a pesar que no est√© interrumpida.

Para saber el estado de una replicaci√≥n ejecute este comando en el slave:

```SQL
SHOW SLAVE STATUS\G
```

Recuerde que el estado de la replicaci√≥n es individual en cada slave. A partir de aqu√≠, tenemos una serie de variables que nos indica que est√° pasando y tambi√©n les explico como resolver cualquiera de estos dos grandes problemas.

### Como identificar una replicaci√≥n interrumpida:

Este problema se puede presentar por una serie de motivos:

* Inconsistencia de datos entre el Master y el Slave.
* Diferentes configuraciones.
* Diferente hora.
* Problemas de red.
* Bloqueos de tablas o de registros.
* Muchos INSERT, UPDATE o DELETES.

Cuando se ejecuta el comando &quot;SHOW SLAVE STATUS&quot; que mencionamos anteriormente, entre todas las variables que nos muestra, debemos hacerle caso a estas:

* **Slave_IO_Running:** Si es &quot;Yes&quot;, entonces el esclavo est√° conectado al master.
* **Slave_SQL_Running:** Si es &quot;Yes&quot;, entonces el esclavo est√° procesando las consultas SQL.
* **Seconds_Behind_Master:** Indica la cantidad de posiciones retrasadas del binlog, si es 0 es que todo est√° bien.
* **Last_Error:** Si &quot;Slave_SQL_Running&quot; es &quot;No&quot;, entonces muestra la √∫ltima sentencia SQL que produjo un error y se detiene la replicaci√≥n.

Para resolver la mayor√≠a de los casos, solo debemos ejecutar estos tres comandos:

```SQL
STOP SLAVE; SET GLOBAL SQL_SLAVE_SKIP_COUNTER=1; START SLAVE;
```

Y volver a ejecutar este comando para verificar que no hayan m√°s errores:

```SQL
SHOW SLAVE STATUS\G
```

Es muy importante saber porque pas√≥ esto y como prevenirlo, el echo de saltar el error y continuar nos crea una inconsistencia de los datos, debemos tomar nota del mensaje de error y resolverlo a mano.

### Como identificar el retraso de la replicaci√≥n:

Primero debemos entender como funciona y cuales son los indicadores que se pueden encontrar en el estado de la replica. La replicaci√≥n en MySQL trabaja con dos hilos, IO_THREAD y SQL_THREAD.

* El primer hilo es IO_THREAD, se conecta a un maestro, lee los eventos del binarios del maestro y los va guardando en un log local llamado **relay log** (registro retrasado). Corresponde este hilo con la variable de estado **Slave_IO_Running**.
* El segundo hilo es SQL_THREAD, lee los eventos del relay log almacenado localmente en el esclavo, el cual fue escrito por el hilo IO_THREAD y luego los aplica lo m√°s r√°pido posible en el slave. Corresponde este hilo con la variable de estado **Slave_SQL_Running**.

Siempre que se presenta un retraso en la replicaci√≥n, es importante saber cual de los dos hilos se encuentra el problema. Normalmente, los hilos de E/S no causar√≠an enormes retrasos de replicaci√≥n, ya que una vez que se leen del master, se aplican en el slave. Sin embargo, el retraso se debe a una limitaci√≥n del hardware o por alguna configuraci√≥n:

* Si es por el rendimiento de la red, afecta al hilo **IO_THREAD**, aqu√≠ debemos evaluar si es un tema de saturaci√≥n de la red, la [NIC][2] no es suficiente para el trafico, u otro problema de red.
* Si es la velocidad del Hardware del slave al procesar el relay log es afectado por el **SQL_THREAD**. Diferentes configuraciones del servicio, indice de los esquemas, carga de trabajo, hardware lento.

Todo estos detalles hay que verlos con mucho cuidado, se requiere paciencia, pero en l√≠neas generales, aqu√≠ se han mencionado todos los puntos que debemos evitar para tener problemas en la replicaci√≥n Master/Slave.

Les deseo suerte.

[1]: https://dev.mysql.com/doc/refman/5.6/en/replication-delayed.html
[2]: https://es.wikipedia.org/wiki/Tarjeta_de_red</content><author><name></name></author><category term="mysql" /><category term="replica" /><category term="slave" /><summary type="html">La replicaci√≥n de datos con slaves es algo muy f√°cil de configurar y aporta muchos beneficios, pero aveces trae sus grandes problemas si no tenemos en cuenta algunos aspectos de configuraci√≥n, hardware y red entre otras cosas, vamos a comentar un buen grupo de ellos y ayudarte a saber donde puede estar el problema, se que es muy largo el POST, hay mucho que cubrir, pero tratare de dar la idea.</summary></entry><entry><title type="html">Buscar registros hu√©rfanos</title><link href="http://0.0.0.0:4000/registros-huerfanos.html" rel="alternate" type="text/html" title="Buscar registros hu√©rfanos" /><published>2016-02-12T00:00:00-06:00</published><updated>2016-02-12T00:00:00-06:00</updated><id>http://0.0.0.0:4000/registros-huerfanos</id><content type="html" xml:base="http://0.0.0.0:4000/registros-huerfanos.html">Los registros hu√©rfanos son aquellos que se almacenan en un modelo relacional padre-hijo, los registros padres hacen referencia a filas primarias, y los registros hijos hacen referencia a filas secundar√≠as, esto puede pasar por varias razones en una DDBB, b√°sicamente sino existe claves for√°neas definidas, o alguien desactivo de forma moment√°nea el check [foreign_key_checks][1], y para mantener la integridad de los datos debemos de vez en cuando identificar estos registros hu√©rfanos, podr√≠amos eliminarlos o asignarlos a un padre de forma provisional. Yo opto m√°s por lo segundo, conservar los datos es nuestra prioridad.

Los registros hu√©rfanos pueden tener un **Foreign Key igual a NULL o tener un ID de un registro primario que no exista**, pero debemos tener bastante cuidado con el NULL, ya que puede hacer referencia a una relaci√≥n &quot;PUEDE&quot; y no &quot;DEBE&quot;, lo cual eliminamos algo que no debemos.

Hay varias formas de hacer esta consulta, pero solo una es la m√°s apropiada por temas de rendimiento, seguramente la condici√≥n que pensamos de primero es **NOT IN**, pues esa no, ni tampoco usar un **LEFT OUTER JOIN**, deber√≠as de usar **NOT EXISTS** que es mucho m√°s eficiente, a continuaci√≥n muestro los tres ejemplos, el √∫ltimo es el bueno:

**A) Primer ejemplo incorrecto:**

```SQL
SELECT count(*)
FROM payment AS child
WHERE rental_id NOT IN (SELECT rental_id FROM rental);
```

**B) Segundo ejemplo incorrecto:**

```SQL
SELECT count(*)
FROM payment AS child
LEFT OUTER JOIN rental AS parent ON parent.rental_id = child.rental_id
WHERE child.rental_id IS NOT NULL AND parent.rental_id IS NULL;
```

**C) Primer ejemplo correcto:**

```SQL
SELECT count(*)
FROM payment AS child
WHERE rental_id IS NOT NULL
  AND NOT EXISTS (
  SELECT NULL FROM rental AS parent WHERE parent.rental_id = child.rental_id
);
```

Hay algo curioso en el ejemplo A y C, a ver si se dan cuenta? La √∫nica pista, es que tiene que ver con los NULL.

Ahora que los hemos identificado, que hacemos con ellos? bueno, la forma correcta ser√≠a la siguiente:

* Agregar un registro primario (padre) para agrupar los registros secundarios (hijos) que est√°n hu√©rfanos.
* Hacer un update en el Foreign Key de todos los registros secundarios con el valor correspondiente al registro primario.
* Verificar que todo este bien.

Espero que les haya sido √∫til.

[1]: http://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_foreign_key_checks</content><author><name></name></author><category term="mysql" /><summary type="html">Los registros hu√©rfanos son aquellos que se almacenan en un modelo relacional padre-hijo, los registros padres hacen referencia a filas primarias, y los registros hijos hacen referencia a filas secundar√≠as, esto puede pasar por varias razones en una DDBB, b√°sicamente sino existe claves for√°neas definidas, o alguien desactivo de forma moment√°nea el check foreign_key_checks, y para mantener la integridad de los datos debemos de vez en cuando identificar estos registros hu√©rfanos, podr√≠amos eliminarlos o asignarlos a un padre de forma provisional. Yo opto m√°s por lo segundo, conservar los datos es nuestra prioridad.</summary></entry><entry><title type="html">Collation, diferencias entre utf8_general_ci y utf8_unicode_ci</title><link href="http://0.0.0.0:4000/collation-diferencias-utf8_general_ci-utf8_unicode_ci.html" rel="alternate" type="text/html" title="Collation, diferencias entre utf8_general_ci y utf8_unicode_ci" /><published>2016-02-08T00:00:00-06:00</published><updated>2016-02-08T00:00:00-06:00</updated><id>http://0.0.0.0:4000/collation-diferencias-utf8_general_ci-utf8_unicode_ci</id><content type="html" xml:base="http://0.0.0.0:4000/collation-diferencias-utf8_general_ci-utf8_unicode_ci.html">Para los que estamos acostumbrados a trabajar en Linux es normal usar el formato de codificaci√≥n UTF-8, y en mi opini√≥n personal es lo que se deber√≠a de usar para todo. En el caso de MySQL se puede definir en una base de datos, tabla y columna el formato de codificaci√≥n como CHARSET y un sub formato llamado COLLATE. La intenci√≥n del COLLATION es poder ayudar en la Presici√≥n vs Rendimiento con los car√°cteres especiales.

Para conocer todos los formatos disponibles de codificaci√≥n y el sub formato por defecto de MySQL, ejecute el siguiente comando:

```SQL
SHOW CHARACTER SET;
```

Como podemos ver en la lista, el COLLATION por defecto de UTF8 es el utf8_general_ci, existe otro llamado utf8_unicode_ci, y entre los dos hay grandes diferencias y al conocerlas entenderemos porque una est√° por defecto:

## Precisi√≥n para ordenar los datos:

* **utf8_unicode_ci:** Se basa en el est√°ndar Unicode para ordenar, y ordena con precisi√≥n en una amplia gama de idiomas.
* **utf8_general_ci:** Se acerca mucho para ordenar correctamente con Unicode en muchos idiomas comunes, pero tiene una serie de imprecisiones al ordenar en algunos idiomas, por lo que no es recomendable para la correcta ordenaci√≥n en todos los idiomas.

## Rendimiento:

* **utf8_general_ci:** Es m√°s r√°pido en las comparaciones y la ordenaci√≥n, est√° puntualmente dise√±ado para el rendimiento, ignora los detalles seg√∫n el idioma.
* **utf8_unicode_ci:** Utiliza un algoritmo mucho m√°s complejo para comparar, tiene como objetivo la clasificaci√≥n correcta de acuerdo en una amplia gama de idiomas. Esto hace que sea m√°s lento para ordenar y comparar un gran n√∫mero de campos.

## Limitaciones:

* No se puede realizar comparaci√≥n directa entre valores de diferente COLLATION, puede resolverlo usando el operador BINARY, pero usar esta alternativa baja mucho el rendimiento.

Quedo claro que el formato por defecto utf8_general_ci es el m√°s r√°pido y el menos impreciso. La definici√≥n de estos formatos depende de nuestras necesidades muy particulares.

La siguiente consulta permite listar todas las tablas que no tienen el collation por defecto:

```SQL
SELECT table_schema, table_name, engine, table_collation
FROM INFORMATION_SCHEMA.TABLES
WHERE table_type = 'BASE TABLE'
  AND table_schema NOT IN ('mysql', 'performance_schema')
  AND (engine &lt;&gt; 'InnoDB' OR  table_collation &lt;&gt; 'utf8_general_ci');
```

Si queremos profundizar un poco m√°s sobre el tema, les dejo los siguientes enlases oficiales de MySQL que explican todo estoy muy bien, y hasta tiene unos ejemplos:

* [Character Sets and Collations in General][1]
* [Examples of the Effect of Collation][2]
* [The BINARY Operator][3]

 [1]: https://dev.mysql.com/doc/refman/5.6/en/charset-general.html
 [2]: https://dev.mysql.com/doc/refman/5.6/en/charset-collation-effect.html
 [3]: https://dev.mysql.com/doc/refman/5.6/en/charset-binary-op.html</content><author><name></name></author><category term="mysql" /><category term="collation" /><summary type="html">Para los que estamos acostumbrados a trabajar en Linux es normal usar el formato de codificaci√≥n UTF-8, y en mi opini√≥n personal es lo que se deber√≠a de usar para todo. En el caso de MySQL se puede definir en una base de datos, tabla y columna el formato de codificaci√≥n como CHARSET y un sub formato llamado COLLATE. La intenci√≥n del COLLATION es poder ayudar en la Presici√≥n vs Rendimiento con los car√°cteres especiales.</summary></entry><entry><title type="html">Bloqueos en MySQL</title><link href="http://0.0.0.0:4000/bloqueos-optimistas-pesimistas-mysql.html" rel="alternate" type="text/html" title="Bloqueos en MySQL" /><published>2015-11-17T00:00:00-06:00</published><updated>2015-11-17T00:00:00-06:00</updated><id>http://0.0.0.0:4000/bloqueos-optimistas-pesimistas-mysql</id><content type="html" xml:base="http://0.0.0.0:4000/bloqueos-optimistas-pesimistas-mysql.html">El bloqueo es la esencia de cualquier manejador de bases de datos relacional (RDBMS), para el caso de MySQL es importante destacar que el engine **InnoDB** lo gestiona de forma √≥ptima, hasta la fecha no hay otro que lo haga mejor.

No podemos confundir bloqueos con [niveles de aislamiento][1], ya que el bloqueo se hace a nivel de registros usando una instrucci√≥n espec√≠fica, mientras el nivel de aislamiento es el comportamiento por defecto para cualquier otra instrucci√≥n normal que manipule los registros.

Los bloqueos existen para poder garantizar el [ACID][2], su correcta implementaci√≥n permite que halla **concurrencia**, de lo contrario se puede presentar la **contenci√≥n** y es fatal.

Los bloqueos los podemos dividir en dos grandes grupos; est√° el bloqueo pesimista y el bloqueo optimista, vamos a entender cada uno:

* **Pesimista:** Es aquel que se apodera del recurso (row/tabla) y no lo libera hasta que se haya modificado. Generalmente se hace con instrucciones propias del RDBMS. Para el caso de MySQL tenemos dos instrucciones; el [SELECT ... FOR UPDATE y el SELECT ... LOCK IN SHARE MODE][3] y no hablar de [LOCK TABLE][4]. √âste tipo de bloqueo produce [Deadlock][5] sin importar la forma como lo controlemos, al final estamos bloqueando un recurso que usa una conexi√≥n especifica, tiene un timeout, y otros procesos que esperan por el, esto puede generar una contenci√≥n, problemas de atomicidad, y muchas m√°s situaciones lamentables.
* **Optimista:** Es la mejor forma de bloquear un recurso fomentando la concurrencia, no existe instrucci√≥n SQL que a√±ada √©sta funcionalidad, m√°s bien usamos las instrucciones DML existentes, y se basa en la l√≥gica del [MVCC][6]. Consiste en a√±adir una columna para versionar el registro y evitar que el √∫ltimo estado sea modificado. Por ejemplo: cuando una sesi√≥n quiere modificar un registro, √©sta lee y hace UPDATE con la √∫ltima versi√≥n conocida de dicho registro, si hay otra transacci√≥n que se adelanta para hacer el mismo UPDATE, la versi√≥n cambia, y el UPDATE ser√° obsoleto.

Para la mayor√≠a de las aplicaciones WEB, se debe utilizar el bloqueo optimista, como podemos ver, no es m√°s que una implementaci√≥n de una columna que versiona el registro y la combinaci√≥n simple de un SELECT y un UPDATE, de esta forma evitamos los [Deadlock][5], la contenci√≥n, y muchos otros problemas. Los ORM, como por ejemplo Hibernate o ActiveRecord tienen √©sta funcionalidad implementada, nos quitan una capa m√°s de detalle y no ser√° necesario modificar el modelo y las consultas.

 [1]: https://www.swapbytes.com/niveles-aislamiento-base-de-datos/
 [2]: https://en.wikipedia.org/wiki/ACID
 [3]: http://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html
 [4]: http://dev.mysql.com/doc/refman/5.7/en/lock-tables.html
 [5]: https://en.wikipedia.org/wiki/Deadlock
 [6]: https://es.wikipedia.org/wiki/Multiversion_concurrency_control</content><author><name></name></author><category term="mysql" /><summary type="html">El bloqueo es la esencia de cualquier manejador de bases de datos relacional (RDBMS), para el caso de MySQL es importante destacar que el engine InnoDB lo gestiona de forma √≥ptima, hasta la fecha no hay otro que lo haga mejor.</summary></entry><entry><title type="html">Seguridad en MySQL con mysql_config_editor</title><link href="http://0.0.0.0:4000/mysql-config-editor.html" rel="alternate" type="text/html" title="Seguridad en MySQL con mysql_config_editor" /><published>2015-07-23T00:00:00-05:00</published><updated>2015-07-23T00:00:00-05:00</updated><id>http://0.0.0.0:4000/mysql-config-editor</id><content type="html" xml:base="http://0.0.0.0:4000/mysql-config-editor.html">En la versi√≥n 5.6.6 se incluyo una nueva herramienta llamada [mysql_config_editor][1], la cual permite almacenar las credenciales de autenticaci√≥n de una forma segura y otros datos b√°sicos en un archivo llamado '.mylogin.cnf' en el directorio home del usuario, luego estas credenciales pueden ser recuperadas para conectarse al servidor de MySQL deseado.

A simple vista no parece, pero es muy importante que considere que **el archivo '.mylogin.cnf' no est√° cifrado**, y no es completamente seguro, pero a√±ade una capa m√°s de seguridad ocultando los datos sensibles por la l√≠nea de comandos. Por ejemplo, ocultamos la contrase√±a en el; historial, alias, logs, scripts, etc... donde puede ser visible de muchas formas.

En el siguiente ejemplo se muestra la forma tradicional de conectarse a una base de datos usando todos los par√°metros b√°sicos; host, usuario y clave:

```bash
$ mysql -h production.db.empresa.org -u root -pmypass
```

Usando la nueva herramienta nos conectamos de la siguiente forma:

```bash
$ mysql --login-path=production
```

Asumiendo que ya hemos creado la configuraci√≥n 'production' usando la herramienta, podemos ver que estamos especificando con el par√°metro '--login-path' para que use la configuraci√≥n 'production' y as√≠ conectarse al servidor.

Para poder agregar una configuraci√≥n, debemos ejecutar el siguiente comando:

```bash
mysql_config_editor set --login-path=production --host=production.db.empresa.org --user=root -p
```

La contrase√±a no se puede pasar por l√≠nea de comando, debemos escribirla para mantenerla un poco m√°s segura. Si queremos conocer todas las configuraciones disponibles, solo debemos ejecutar el siguiente comando:

```bash
mysql_config_editor print --all
```

Si queremos aprender m√°s sobre esta herramienta, recomiendo [visitar su p√°gina web][1].

[1]: http://dev.mysql.com/doc/refman/5.6/en/mysql-config-editor.html</content><author><name></name></author><category term="mysql" /><category term="cli" /><summary type="html">En la versi√≥n 5.6.6 se incluyo una nueva herramienta llamada mysql_config_editor, la cual permite almacenar las credenciales de autenticaci√≥n de una forma segura y otros datos b√°sicos en un archivo llamado ‚Äò.mylogin.cnf‚Äô en el directorio home del usuario, luego estas credenciales pueden ser recuperadas para conectarse al servidor de MySQL deseado.</summary></entry><entry><title type="html">Origen de la palabra NoSQL</title><link href="http://0.0.0.0:4000/origen-nosql.html" rel="alternate" type="text/html" title="Origen de la palabra NoSQL" /><published>2015-06-08T00:00:00-05:00</published><updated>2015-06-08T00:00:00-05:00</updated><id>http://0.0.0.0:4000/origen-nosql</id><content type="html" xml:base="http://0.0.0.0:4000/origen-nosql.html">Es curioso como se desencadena toda una revoluci√≥n por un simple hashtag. Aqu√≠ les dejo una breve historia de su verdadero origen:

Johan Oskarsson organiz√≥ un evento en Junio de 2009 en San Francisco, la intenci√≥n era discutir las nuevas tecnolog√≠as en el mundo IT sobre el almacenamiento y procesamiento de datos. La principal raz√≥n del evento fueron los nuevos productos como BigTable y Dynamo. Para el evento era necesario encontrar una palabra clave para ser usada en un hashtag de Twitter, t√©rmino siendo **&quot;[NoSQL](http://es.wikipedia.org/wiki/NoSQL)&quot;** y fue sugerido por Eric Evans de RackSpace. El t√©rmino fue planeado para ser utilizado s√≥lo para √©sta reuni√≥n y no ten√≠a un significado profundo. Pero result√≥ que se extendi√≥ por la red de forma viral y se convirti√≥ en el nombre de facto de una tendencia de las bases de datos no relacionales y distribuidas.

El t√©rmino &quot;NoSQL&quot; tiene un origen absolutamente natural y √©ste no est√° avalado por una instituci√≥n cient√≠fica. Se considera que el t√©rmino esta lejos de su completa definici√≥n, hay autores como Pramod J. Sadalage y Martin Fowler que trataron de agrupar y organizar todo el conocimiento sobre el mundo NoSQL en el libro &quot;[NoSQL destilada](http://www.amazon.com/NoSQL-Distilled-Emerging-Polyglot-Persistence/dp/0321826620)&quot;.

**Fuentes:**

* [Introduction to NoSQL by Martin Fowler](https://www.youtube.com/watch?v=qI_g07C_Q5I)
* [World of the NoSQL databases](http://leopard.in.ua/2013/11/08/nosql-world/)</content><author><name></name></author><category term="database" /><category term="nosql" /><summary type="html">Es curioso como se desencadena toda una revoluci√≥n por un simple hashtag. Aqu√≠ les dejo una breve historia de su verdadero origen:</summary></entry></feed>